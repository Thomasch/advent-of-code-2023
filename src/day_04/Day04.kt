package day_04

import println
import readInput
import kotlin.math.pow

fun main() {

    data class Scratchcard(val id: Int, var amount: Int = 1)

    /**
     * Splits the line into winning numbers and other numbers and returns the matches
     */
    fun calculateMatches(it: String): Int {
        return it.split("|").let { split ->
            val winningNumbers = split[0].split(" ").filterNot { it.isBlank() }
            val otherNumbers = split[1].split(" ").filterNot { it.isBlank() }
            winningNumbers.count { number -> otherNumbers.contains(number) }
        }
    }

    /**
     * As far as the Elf has been able to figure out, you have to figure out which
     * of the numbers you have appear in the list of winning numbers. The first
     * match makes the card worth one point and each match after the first doubles
     * the point value of that card.
     */
    fun part1(input: List<String>): Int {
        return input.sumOf { line ->
            calculateMatches(line).let { count ->
                if (count != 0) 2.0.pow(count - 1) else 0
            }.toInt()
        }
    }

    /**
     * There's no such thing as "points". Instead, scratchcards only cause you to
     * win more scratchcards equal to the number of winning numbers you have.
     * Specifically, you win copies of the scratchcards below the winning card
     * equal to the number of matches. So, if card 10 were to have 5 matching
     * numbers, you would win one copy each of cards 11, 12, 13, 14, and 15.
     *
     * In this solution I first create a list of scratchcards with an initial
     * amount of one. When the number of matches is found, the copies are
     * generated by updating the amounts of the cards affected with the current
     * card's amount. This way I avoid having to recalculate matches for each
     * copy, which can be very inefficient.
     */
    fun part2(input: List<String>): Int {
        return input.indices.map { Scratchcard(it) }.let { totalCards ->
            totalCards.sumOf { currentCard ->
                val matches = input.getOrNull(currentCard.id)?.let { calculateMatches(it) }
                (1..(matches ?: 0)).forEach { winningCard ->
                    totalCards.getOrNull(winningCard + currentCard.id)
                            ?.run { amount += currentCard.amount }
                }
                currentCard.amount
            }
        }
    }

    // test if implementation meets criteria from the description, like:
    val testInputPart1 = readInput("day_04/Day04_test")
    check(part1(testInputPart1) == 13)

    val testInputPart2 = readInput("day_04/Day04_test")
    check(part2(testInputPart2) == 30)

    val input = readInput("day_04/Day04")
    part1(input).println()
    part2(input).println()
}
